<!--
@license
(C) Copyright Nuxeo Corp. (http://nuxeo.com/)

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->

<link rel="import" href="../../bower_components/polymer/polymer.html">
<link rel="import" href="../../bower_components/iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="../../bower_components/nuxeo-elements/nuxeo-resource.html">
<link rel="import" href="../../bower_components/nuxeo-ui-elements/nuxeo-layout.html">
<link rel="import" href="../../bower_components/nuxeo-ui-elements/widgets/nuxeo-select.html">
<link rel="import" href="../../bower_components/nuxeo-ui-elements/nuxeo-data-table/iron-data-table.html">
<link rel="import" href="../../bower_components/paper-button/paper-button.html">
<link rel="import" href="../../bower_components/paper-card/paper-card.html">
<link rel="import" href="../../bower_components/paper-item/paper-item.html">
<link rel="import" href="../../bower_components/paper-button/paper-button.html">
<link rel="import" href="../../bower_components/paper-icon-button/paper-icon-button.html">
<link rel="import" href="../../bower_components/paper-tooltip/paper-tooltip.html">
<link rel="import" href="../../bower_components/paper-dialog/paper-dialog.html">
<link rel="import" href="../nuxeo-app/nuxeo-page.html">

<!--
`nuxeo-vocabulary-management`
@group Nuxeo UI
@element nuxeo-vocabulary-management
-->
<dom-module id="nuxeo-vocabulary-management">
  <template>
    <style>
      :host {
        display: block;
      }

      nuxeo-data-table {
        min-height: calc(100vh - 280px);
      }

      .top.actions {
        @apply --layout-horizontal;
        @apply --layout-center;
        @apply --layout-end-justified;
        margin: 1em 0 1em 0;
      }

      nuxeo-select {
        max-width: 223px;
      }

      paper-dialog {
        min-width: 480px;
      }

      @media (max-width: 1024px) {
        paper-dialog {
          min-width: 0;
          width: 90%;
        }
      }

      paper-dialog .buttons {
        @apply --layout-horizontal;
        @apply --layout-justified;
        margin-top: 16px;
        background-color: var(--nuxeo-dialog-buttons-bar, white);
      }

      label {
        @apply --nuxeo-label;
      }
    </style>

    <nuxeo-resource id="directory" path="/directory"></nuxeo-resource>

    <nuxeo-page>
      <div slot="header">
        <span>[[i18n('vocabularyManagement.heading')]]</span>
      </div>

      <div>
        <paper-card elevation="0" class="block">
          <nuxeo-select label="[[i18n('vocabularyManagement.vocabulary')]]"
                        placeholder="[[i18n('vocabularyManagement.select')]]"
                        selected="{{selectedVocabulary}}" attr-for-selected="name">
            <template is="dom-repeat" items="[[vocabularies]]" as="vocabulary">
              <paper-item name$="[[vocabulary.name]]">[[vocabulary.name]]</paper-item>
            </template>
          </nuxeo-select>
        </paper-card>

        <template is="dom-if" if="[[_isVocabularySelected(selectedVocabulary)]]">
          <div class="top actions">
            <paper-button id="addEntry" class="primary" on-tap="_createEntry">
              <span>+ [[i18n('vocabularyManagement.addEntry')]]</span>
            </paper-button>
          </div>
          <nuxeo-data-table id="table"
            empty-label="[[i18n('vocabularyManagement.noEntry')]]"
            empty-label-when-filtered="[[i18n('vocabularyManagement.noEntryWhenFiltered')]]">
            <template is="dom-repeat" items="[[colDef]]" as="col">
              <nuxeo-data-table-column name="[[i18n(col.name)]]" key="[[col.key]]">
                <template>
                  <template is="dom-if" if="[[!_entryActions(column.key)]]">
                    [[_value(index, column.key)]]
                  </template>
                  <template is="dom-if" if="[[_entryActions(column.key)]]">
                    <paper-icon-button id="edit-button-[[index]]" icon="nuxeo:edit" on-tap="_editEntry"></paper-icon-button>
                    <paper-tooltip for="edit-button-[[index]]">[[i18n('vocabularyManagement.editEntry')]]</paper-tooltip>
                    <paper-icon-button id="delete-button-[[index]]" name="delete" icon="nuxeo:delete" on-tap="_deleteEntry"></paper-icon-button>
                    <paper-tooltip for="delete-button-[[index]]">[[i18n('vocabularyManagement.deleteEntry')]]</paper-tooltip>
                  </template>
                </template>
              </nuxeo-data-table-column>
            </template>
          </nuxeo-data-table>
        </template>
      </div>
    </nuxeo-page>

    <paper-dialog id="dialog" with-backdrop no-auto-focus>
      <h2>[[i18n('vocabularyManagement.popup.editEntry')]]</h2>
      <form id="form" is="iron-form" action="/">
        <nuxeo-layout id="layout"
                      href="[[_layoutHref(_selectedSchema)]]"
                      model="[[_layoutModel(_selectedEntry)]]"
                      error="[[i18n('documentVocabularyManagement.layoutNotFound', _selectedSchema)]]">
        </nuxeo-layout>
      </form>
      <div class="buttons">
        <paper-button name="cancel" noink dialog-dismiss>[[i18n('command.cancel')]]</paper-button>
        <paper-button name="save" noink class="primary" on-tap="_save">[[i18n('command.save')]]</paper-button>
      </div>
    </paper-dialog>

  </template>

  <script>
    Polymer({
      is: 'nuxeo-vocabulary-management',
      behaviors: [Nuxeo.I18nBehavior],
      properties: {
        vocabularies: Array,
        selectedVocabulary: String,
        entries: {
          type: Array,
          value: []
        },
        colDef: {
          type: Object,
          notify: true
        },
        visible: {
          type: Boolean,
          observer: '_visibleChanged'
        },
        _selectedEntry: {
          type: Object
        },
        _selectedSchema: {
          type: String,
          computed: '_schemaFor(_selectedEntry)'
        }
      },

      observers: [
        '_refresh(selectedVocabulary)'
      ],

      _visibleChanged: function() {
        if (this.visible && !this.vocabularies) {
          this.$.directory.get().then(function(response) {
            this.vocabularies = response.entries;
          }.bind(this));
        }
      },

      /**
       * Returns the href for the current layout element
       */
      _layoutHref: function(schema) {
        return this.resolveUrl(schema + '/nuxeo-' + schema + '-edit-layout.html');
      },

      _layoutModel: function() {
        return {
          entry: this._selectedEntry,
          parentDirectory: this._getParentDirectoryFor(this._selectedEntry),
          entries: this.entries,
          "new": this._new
        };
      },

      _schemaFor: function(entry) {
        if (!entry) {
          return;
        }
        var schema = '';
        for (var i in this.vocabularies) {
          if (this.vocabularies[i].name === entry.directoryName) {
            schema = this.vocabularies[i].schema;
            break;
          }
        }
        if (!schema || schema.length === 0) {
          return 'vocabulary';
        }
        return schema;
      },

      _getParentDirectoryFor: function(entry) {
        var parent = '';
        for (var i in this.vocabularies) {
          if (this.vocabularies[i].name === entry.directoryName) {
            parent = this.vocabularies[i].parent;
            break;
          }
        }
        return parent;
      },

      _entryActions: function(o) {
        return o  === 'actions';
      },

      _refresh: function() {
        if (this.selectedVocabulary && this.selectedVocabulary.length > 0) {
          this.$.directory.path = '/directory/' + this.selectedVocabulary;
          this.entries = [];
          this.colDef = [];
          this.$.directory.get().then(function(resp) {
            var tmp = [];
            if (resp.entries.length > 0) {
              tmp = Object.keys(resp.entries[0].properties).map(function(key) {
                return {key: key, name: 'vocabularyManagement.edit.' + key, pos: this._computeColPos(key)};
              }.bind(this));
            }
            tmp.push({key: 'actions', name: 'vocabularyManagement.edit.actions', pos: 1000, actions: true});
            tmp.sort(function(a, b) {
              return a.pos - b.pos;
            });
            this.colDef = tmp;
            this.entries = resp.entries;

            var table = this.$$('#table');
            table.items = [];
            table.items = this.entries;
          }.bind(this));
        }
      },

      _displayTable: function() {
        return this.selectedVocabulary && this.selectedVocabulary.length > 0;
      },

      _value: function(index, prop) {
        var entry = this.entries[index];
        if (entry && entry.properties && prop) {
          if (prop === 'obsolete') {
            return entry.properties[prop] > 0 ? this.i18n('label.yes') : this.i18n('label.no');
          }
          return entry.properties[prop];
        } else {
          console.error('Could not resolve property ' + prop);
          return 'N/A';
        }
      },

      _computeColPos: function(key) {
        if (key === 'parent') {
          return 1;
        } else if (key === 'id') {
          return 2;
        } else if (key === 'obsolete') {
          return 98;
        } else if (key === 'ordering') {
          return 99;
        } else {
          return 50;
        }
      },

      _deleteEntry: function(e) {
        if (confirm(this.i18n('vocabularyManagement.confirmDelete'))) {
          var item = e.target.parentNode.item;
          this.$.directory.path = '/directory/' + item.directoryName + '/' + item.properties.id;
          this.$.directory.remove().then(function() {
            this._refresh();
            this.fire('notify', {message: this.i18n('vocabularyManagement.successfullyDeleted')});
          }.bind(this), function(err) {
            if (err.status === 401) {
              this.fire('notify', {message: this.i18n('label.error').toUpperCase() + ': ' +
                                            this.i18n('vocabularyManagement.cannotDelete.referencedEntry')});
            } else {
              this.fire('notify', {message: this.i18n('label.error').toUpperCase() + ': ' +
                                            this.i18n('vocabularyManagement.cannotDelete.error')});
            }
          }.bind(this));
        }
      },

      _editEntry: function(e) {
        this._new = false;
        this._selectedEntry = e.target.parentNode.item;
        this.$.dialog.toggle();
      },

      _cancel: function() {
        //this._refresh();
      },

      _save: function() {

        this.$.directory.data = this._selectedEntry;
        if (this._new) {
          this.$.directory.path = '/directory/' + this._selectedEntry.directoryName;
          this.$.directory.post().then(function() {
            this.$.dialog.toggle();
            this.fire('notify', {message: this.i18n('vocabularyManagement.successfullyCreated')});
            this._refresh();
          }.bind(this),
          function(err) {
            this.fire('notify', {message: this.i18n('label.error').toUpperCase() + ': ' +
                                          (err.message && err.message.length > 0 ? err.message :
                                           this.i18n('vocabularyManagement.cannotCreate'))});
          }.bind(this));
        } else {
          this.$.directory.path = '/directory/' + this._selectedEntry.directoryName +
            '/' + this._selectedEntry.properties.id;
          this.$.directory.put().then(function() {
            this.$.dialog.toggle();
            this.fire('notify', {message: this.i18n('vocabularyManagement.successfullyEdited')});
            this._refresh();
          }.bind(this),
          function(err) {
            this.fire('notify', {message: this.i18n('label.error').toUpperCase() + ': ' +
                                          (err.message && err.message.length > 0 ? err.message :
                                           this.i18n('vocabularyManagement.cannotEdit'))});
          }.bind(this));
        }
      },

      _isVocabularySelected: function() {
        return this.selectedVocabulary && this.selectedVocabulary.length > 0;
      },

      _createEntry: function() {
        var emptyEntry = JSON.parse(JSON.stringify(this.entries[0]));
        for (var property in this.entries[0].properties) {
          if (this.entries[0].properties.hasOwnProperty(property)) {
            emptyEntry.properties[property] = undefined;
          }
        }
        this._new = true;
        this._selectedEntry = emptyEntry;
        this.$.dialog.toggle();
      }

    });
  </script>
</dom-module>
